<!DOCTYPE html>





<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
<meta name="keywords" content="前端,js,jquery,javascript,html5,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,Geek,html,css,css3,用户体验">
<meta property="og:type" content="website">
<meta property="og:title" content="小新没蜡笔的Blog">
<meta property="og:url" content="//likamoer.me/index.html">
<meta property="og:site_name" content="小新没蜡笔的Blog">
<meta property="og:description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小新没蜡笔的Blog">
<meta name="twitter:description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
  <link rel="alternate" href="/atom.xml" title="小新没蜡笔的Blog" type="application/atom+xml">
  <link rel="canonical" href="//likamoer.me/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>小新没蜡笔的Blog</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container">
    <div class="headband">
    <a href="https://github.com/likamoer"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小新没蜡笔的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">遍历山河, 人间值得</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-phone">
      
    

    <a href="/phone/" rel="section"><i class="menu-item-icon fa fa-fw fa-image"></i> <br>图片</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-music">
      
    

    <a href="/music/" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i> <br>音乐</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-certificate"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-welfare">
      
    

    <a href="/welfare/" rel="section"><i class="menu-item-icon fa fa-fw fa-coffee"></i> <br>福利</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-home">
            
  <section id="posts" class="posts-expand">
      

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="//likamoer.me/2019/09/10/content/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="likamoer">
      <meta itemprop="description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小新没蜡笔的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/10/content/" class="post-title-link" itemprop="url">js变量对象</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-10 14:06:16 / 修改时间：15:13:32" itemprop="dateCreated datePublished" datetime="2019-09-10T14:06:16+08:00">2019-09-10</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>对于每个执行上下文, 都有三个重要属性:<ul>
<li>变量对象()</li>
<li>作用域链(scope chain)</li>
<li>this</li>
</ul>
</li>
</ul>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><ul>
<li>创建变量对象的过程</li>
<li>变量对象是与执行上下文相关的数据作用域, 存储了在上下文中定义的变量和函数声明;</li>
<li>不同执行上下文中的变量对象稍有不同, 全局上下文和函数上下文中的变量对象;</li>
</ul>
<h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>我们先了解一下 什么叫<em>全局上下文</em>:</p>
<blockquote>
<p>全局对象是预定义的对象, 作为javascript的全局函数和全局属性的占位符. 通过使用全局对象,可以访问所有的全局预定义属性, 函数, 和对象.<br>在顶层javascript代码中, 可以用关键词this引用全局对象. 因为全局对象是作用域链的头这意味着所有非限定的变量和函数名都会作为该对象的属性来查询</p>
<ul>
<li>例如在javascript中使用parseInt函数,它引用的是全局对象的parseInt属性, 全局对象是作用域链的头, 这意味着在顶层javascript代码中申明的所有变量,都将成为全局对象的属性.</li>
</ul>
</blockquote>
<ol>
<li><p>可以通过this引用, 在javascript中, 全局对象就是window对象;</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局对象是由Object构造函数实例化的一个对象</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>预定义了一堆函数加对象加属性</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(Math.<span class="built_in">ceil</span>())</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">this</span>.Math.<span class="built_in">ceil</span>())</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为全局变量的宿主</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span></span><br><span class="line">console.log(this.a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>js中, 全局对象指向window自身</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span></span><br><span class="line">console.log(window.a)</span><br><span class="line">this<span class="selector-class">.window</span><span class="selector-class">.b</span> = <span class="number">2</span></span><br><span class="line">console.log(this.b) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><em>总结一句话: 全局上下文中的变量对象就是全局对象呐！</em></p>
<h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><hr>
<p>在函数上下文中, 我们用活动对象来表示变量对象;<br>活动对象和变量对象其实是一个东西, 只是变量对象是规范上的或者说是引擎上实现的,不可以在javascript环境中去访问, 只有当进入一个执行上下文中, 这个执行环境上下文中的对象才被激活,, 所以才会叫activation object,而只有被激活的变量对象,也就是活动对象上的各种属性才能被访问;</p>
<p>活动对象是在进入函数上下文时刻被创建, 他通过函数的arguments属性初始化.arguments属性值是Arguments对象;</p>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><hr>
<p>执行上下文的代码会分成两个部分, 两个阶段做处理: 分析和执行, 我们也可以叫做:</p>
<ul>
<li>进入执行上下文</li>
<li>代码执行</li>
</ul>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文的时候, 这时候还没有执行代码,<br>变量对象会包括: </p>
<ol>
<li>函数的所有形参(如果是函数上下文)<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
</li>
<li>函数声明<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li>变量声明<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性<br>举个栗子:<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p>在进入执行上下文后，这时候的 AO 是：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="keyword">argument</span><span class="variable">s:</span> &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="variable">a:</span> <span class="number">1</span>,</span><br><span class="line">    <span class="variable">b:</span> undefined,</span><br><span class="line">    <span class="keyword">c</span>: reference <span class="keyword">to</span> <span class="function"><span class="keyword">function</span> <span class="title">c</span><span class="params">()</span>&#123;&#125;,</span></span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值<br>还是上面的例子，当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="keyword">argument</span><span class="variable">s:</span> &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="variable">a:</span> <span class="number">1</span>,</span><br><span class="line">    <span class="variable">b:</span> <span class="number">3</span>,</span><br><span class="line">    <span class="keyword">c</span>: reference <span class="keyword">to</span> <span class="function"><span class="keyword">function</span> <span class="title">c</span><span class="params">()</span>&#123;&#125;,</span></span><br><span class="line">    d: reference <span class="keyword">to</span> FunctionExpression <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p>
<ol>
<li>全局上下文的变量对象初始化是全局对象</li>
<li>函数上下文的变量对象初始化只包括 Arguments 对象</li>
<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li>
<li>在代码执行阶段，会再次修改变量对象的属性值</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="//likamoer.me/2019/08/26/proto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="likamoer">
      <meta itemprop="description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小新没蜡笔的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/proto/" class="post-title-link" itemprop="url">JavaScript底层原理 -- 原型和原型链的认识</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:17:36" itemprop="dateCreated datePublished" datetime="2019-08-26T15:17:36+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-27 12:06:06" itemprop="dateModified" datetime="2019-08-27T12:06:06+08:00">2019-08-27</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><hr>
<ol>
<li>我们先使用构造函数创建一个对象:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)  </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person.name = <span class="string">'john'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// john</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>栗子讲解:<br>    在上面这个栗子中那, 我们创建了一个构造函数Person, 并且实例化了一个person, 将person的name赋值并打印</p>
</blockquote>
<ol start="2">
<li>接下来进入正题 – <strong><em>prototype</em></strong><br>每个函数都有一个prototype的属性,就是我们经常在各种栗子中看到的那个神秘的prototype, 例如:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'likamoer'</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// likamoer</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// likamoer</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>注意: prototype是<strong>函数</strong>才会有的属性, 实例里面没有<br>好啦, 那么这个prototype到底指向什么那?是这个函数的原型嘛?<br>其实, 函数的prototype的属性指向了一个对象, 这个对象正是调用了该构造函数的而创建的实例的原型,也就是这个栗子中的preson1和preson2的原型</li>
</ul>
<p>那什么是原型那?<br>可以这样理解: 每一个javascript对象在创建的时候就会与之关联一个对象(也是我们所说的原型对象), 每一个对象都会从原型对象里面”继承”属性.<br>让我们用一张图来解释下这个关系:<br><img src="/2019/08/26/proto/prototype1.png" alt></p>
<p>在这张图中我们中Object.prototype表示实例原型.<br>那么我们该怎么表示实例与实例原型的关系那, 也就是preson和Preson的关系那,这时候我们就要讲到第二个属性:</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><hr>
<p>这是每一个javascript对象都具有的属性,叫<strong>proto</strong>, 这个属性会指向该对象的原型.<br>为了证明这一点, 可以写一个demo来实现一下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>于是我们更新一下上面的图:<br><img src="/2019/08/26/proto/prototype2.png" alt><br>到这里,提出一个问题,既然实例对象和构造函数都可以指向原型,那么原型是否有属性指向构造函数或者实例那?</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><hr>
<p>指向实例的没有,因为一个构造函数可以创建多个实例,但是原型指向构造函数确实有的,这就要讲到第三个属性– constructor, 每一个原型都有一个constructor属性指向对应的构造函数.</p>
<p>为了验证这一点, 我们可以尝试:</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> <span class="params">()</span> <span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span><span class="params">(Person == Person.prototype.<span class="keyword">constructor</span>)</span> <span class="comment">// true</span></span></span><br></pre></td></tr></table></figure>

<p>所以我们再更新一下指向图:<br><img src="/2019/08/26/proto/prototype3.png" alt></p>
<p>综上, 我们已经得出: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line">cosnole.log(Person == Person.prototype.constructor) <span class="comment">// true</span></span><br><span class="line">cosnole.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true es5的方法,可以获取到实例的原型对象</span></span><br></pre></td></tr></table></figure>

<p>了解了构造函数, 实例原型,和实例之间的关系, 接下来我们讲一讲实例与原型之间的关系:</p>
<h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><hr>
<p>当使用到实例的属性的时候, 如果找不到,就会去该实例的原型对象上去找, 如果还没有找到就去原型的原型上查找,一直找到顶层对象为止;<br>举个栗子:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person<span class="selector-class">.prototype</span><span class="selector-class">.name</span> = <span class="string">'likamoer'</span></span><br><span class="line"><span class="selector-tag">var</span> person = new Person()</span><br><span class="line">person<span class="selector-class">.name</span> = <span class="string">'test'</span></span><br><span class="line">console.log(person.name) <span class="comment">// test</span></span><br><span class="line">delete person.name</span><br><span class="line">console.log(person.name) <span class="comment">// likamoer</span></span><br></pre></td></tr></table></figure>

<p>在这个栗子中,我们定义了一个Person 并且在他的原型对象上增加了一个name属性, 实例化了一个person, 并且给该实例添加了已个name属性,现在我们打印了实例的name, 能够获取到刚刚设置的name属性, 接下来, 我们删除了该name属性, 实例本身没有啦name属性, 但我们依然去打印实例属性的name值, 发现也可以打印出来,并且是构造函数的name属性值.这说明了 实例本身有的属性会覆盖其原型对象上的属性,但是本身没有的属性, 实例会沿着<strong>proto</strong>原型链去寻找上一层.<br>那么, 上一层中也没有,会怎么办? 原型的原型又是什么?</p>
<h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><hr>
<p>在前面我们已经讲到了, 原型那,是一个对象, 既然是对象,我们就可以使用最原始的方法去创建他,那就是:</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = new <span class="keyword">Object</span>()</span><br><span class="line">obj.<span class="keyword">name</span> = <span class="string">'likamoer'</span></span><br><span class="line">console.log(obj.<span class="keyword">name</span>) <span class="comment">// likamoer</span></span><br></pre></td></tr></table></figure>

<p>其实原型对象就是通过Objec()构造函数生成的, 结合之前所讲, 实例的<strong>proto</strong>指向的构造函数的原型(prototype), 所以我们再更新下图:<br><img src="/2019/08/26/proto/prototype4.png" alt></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><hr>
<p>那Object.prototype的原型那?<br>null, 我们可以打印:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>然而null究竟代表了什么?</p>
<blockquote>
<p>null表示此处没有对象, 即此处不该有值<br>所以Object.prototype.<strong>proto</strong>, 为null跟Object.prototype没有原型其实是一个意思<br>所以查找属性的时候查到Object.prototype就可以停止查找了<br>最后一张关系图也可以更新为:<br><img src="/2019/08/26/proto/prototype5.png" alt><br>顺便说一下, 图中由相互关联的原型组成的链状结构,就是原型链, 也是就蓝色的这条线</p>
</blockquote>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><hr>
<p>最后, 补充三点大家不怎么注意的地方<br><em>constructor</em><br>首先是constructor属性, 我们先来举个栗子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取person.constructor时, 其实person实例本身没有constructor属性, 当不能读到constructor属性的时候, 前面我们已经讲到了, 他会往上级的prototype中去找, 会从person的原型对象中去找,也就是Person.prototype中找, 这里面有,所以就能拿到<br><code>person.constructor == Person.prototype.constructor</code></p>
<p><em><strong>proto</strong></em><br>其次是<strong>proto</strong>, 绝大部分浏览器都支持这个非标准的方法访问原型然而它并不存在域原型中, 实际上,它是来自于Object.prototype, 与其说是一个属性,还不如说是一个getter或者setter, 当使用obj.<strong>proto</strong>时, 其实返回了Object.getPrototypeOf(obj)</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="//likamoer.me/2019/08/26/scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="likamoer">
      <meta itemprop="description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小新没蜡笔的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/scope/" class="post-title-link" itemprop="url">词法作用域与动态作用域</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:17:05" itemprop="dateCreated datePublished" datetime="2019-08-26T15:17:05+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-28 11:03:47" itemprop="dateModified" datetime="2019-08-28T11:03:47+08:00">2019-08-28</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><hr>
<p>作用域是指程序源代码当中变量的定义区域<br>作用域规定了如何查找变量, 也就是确定当前执行代码对变量的访问权限<br>而js采用的是词法作用域,也就是静态作用域.</p>
<h2 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h2><hr>
<p>因为javascript采用的是静态作用域, 函数的作用域在函数定义时就已经定义好啦;<br>而与静态作用域相对的动态作用域, 函数的作用域是在函数运行的时候才定义的;<br>举个栗子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span></span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line">bar() <span class="comment">// 结果是?</span></span><br></pre></td></tr></table></figure>

<p>假设js采用的是静态作用域, 那么分析一下过程:<br>执行foo函数, 执行foo函数的时候,先从foo函数内部查找是否有局部变量value,如果没有,就往上一层查找, 那就是1,所以结果会打印出1<br>假设js采用的是动态作用域, 那么分析一下过程:<br>执行foo函数,依然是从内部开始查找value, 如果没有, 就从调用函数的作用域开始查询,也就是bar内查询是否存在value, 找到了 value = 2 所以会打印2</p>
<p><em>综上所述</em><br>因为我们知道js是静态作用域, 所以打印出1,</p>
<h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><hr>
<p>那作为一枚优秀的程序员, 肯定也想知道什么是动态作用域<br>简单来说, 动态,就是根据调用它的位置所在的执行上下文,也就是作用域来确定;</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><hr>
<p>最后让我们来看一个思考的题目, 更容易理解:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line">&#125;</span><br><span class="line">checkScope() <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkScope()()</span><br></pre></td></tr></table></figure>

<p>猜一猜两段代码会输出什么?<br>直接公布答案: 两段代码都会打印出 <em>local scope</em><br>原因很简单: js采用的是静态作用域, 函数的作用域取决于函数创建的位置;<br>引用&lt;&lt;js权威指南里面的一句话&gt;&gt;</p>
<blockquote>
<p>javascript函数的执行,应用到了作用域链, 这个作用域链是在函数创建的时候创建的.嵌套的函数f()是定义在这个作用域链里, 所以 其中的scope变量一定是局部变量,不管何时何地执行f(), 依然有效;</p>
</blockquote>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="//likamoer.me/2019/08/23/js-event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="likamoer">
      <meta itemprop="description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小新没蜡笔的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/js-event/" class="post-title-link" itemprop="url">两道面试题引发的思考</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-23 15:07:24 / 修改时间：15:24:52" itemprop="dateCreated datePublished" datetime="2019-08-23T15:07:24+08:00">2019-08-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-两道面试题引发的思考"><a href="#1-两道面试题引发的思考" class="headerlink" title="1. 两道面试题引发的思考:"></a>1. 两道面试题引发的思考:</h2><ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span></span><br><span class="line">    setTimeout(resolve, <span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time();</span><br><span class="line">    <span class="keyword">await</span> wait();</span><br><span class="line">    <span class="keyword">await</span> wait();</span><br><span class="line">    <span class="keyword">await</span> wait();</span><br><span class="line">    <span class="built_in">console</span>.timeEnd();</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先看到这道面试题, 会先意识到这是一个异步函数的应用,考察的应该是异步函数调用的知识;</p>
</li>
<li><p>wait是一个promise函数,里面是一个setTimeout函数,模拟异步请求,10秒之后resolve;</p>
</li>
</ul>
<p><em>回归一下promise的知识</em>:</p>
<ul>
<li><p>promise承诺函数, new了一个promise函数;</p>
</li>
<li><p>执行了系列操作,之后必须使用调用promise参数里面的resolve()或者是reject()</p>
</li>
<li><p>resolve()成功时的回调,reject()失败时的回调;</p>
</li>
<li><p>二者选其一</p>
</li>
<li><p>async和await, promise的语法糖, 将异步函数同步调用, 顺序执行,只有等待await后面的promise函数返回结果之后才会执行下面的语句,因此在这里,main函数被包装成了async的形式, 里面的三个await顺序执行, 依次等待才会执行console.timeEnd()</p>
</li>
<li><p>所以, 综上所述, 目前来看输出的时间会是30秒</p>
</li>
<li><p>— 但是, 这里有个但是—</p>
</li>
<li><p>我们知道,js里面所有的函数执行都是需要时间的,因此,在事件队列里面,将事件加入事件队列,以及从事件队列里面清除事件都是需要一定的时间,尽管时间很少,也是存在的;例如: </p>
</li>
<li><p>将事件写入微任务队列, 再将微任务队列写入到任务队列,都是需要时间</p>
<h2 id="再来看另外一道面试题"><a href="#再来看另外一道面试题" class="headerlink" title="再来看另外一道面试题:"></a>再来看另外一道面试题:</h2></li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span></span><br><span class="line">    setTimeout(resolve, <span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">let</span> a = wait();</span><br><span class="line"><span class="keyword">let</span> b = wait();</span><br><span class="line"><span class="keyword">let</span> c = wait();</span><br><span class="line"><span class="keyword">await</span> a;</span><br><span class="line"><span class="keyword">await</span> b;</span><br><span class="line"><span class="keyword">await</span> c;</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line">&#125;  </span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
</li>
<li><p>大体看上去和之前的的那一道差不多,只是在async里的函数里面将await函数换了一种方式,</p>
</li>
<li><p>—但是, 这里有一个但是—</p>
</li>
<li><p>就是因为这种写法,导致这种写法的输出结果和之前的的结果截然不同</p>
</li>
</ul>
<p><em>分析一下:</em></p>
<ul>
<li>首先先解析一下js的运行机制:</li>
<li>js是单线程的, 虽然推出了web worker标准,允许js创建多个线程,但是子线程完全受主线程的控制,并且不能操作DOM,所以在本质上来讲没有违背单线程的初衷</li>
<li>单线程,意味着js在执行任务时是一个一个的执行,如果前一个任务执行的时间很长,那么后面的任务就会一直等待,也就是我们说的阻塞了,这样的机制使得用户体验很差,js的设计者考虑到了这一点,所以他将js中的任务分为两种 — 同步任务(在主线上执行的任务) — 异步任务(被主线程挂载起来的任务) ,而异步任务一般存放在事件任务队列(一种数据结构)里面;</li>
</ul>
<p><em>所以js的运行机制就是围绕着这两种任务来执行</em><br>    - (1)所有的同步任务都在主线上执行,形成一个执行栈;<br>    - (2)主线程之外还有一个任务队列, 只要异步任务有了运行结果,就在任务队列中放置一个事件;<br>    - (3)一旦执行栈里面的所有的同步任务执行完毕了系统就会读取”任务队列”,看看里面有哪些事件,那些对应的异步任务,于是将异步任务结束等待状态,推进执行栈,开始执行;<br>    - (4)主线程不断执行以上三步(我们所说的事件循环)</p>
<ul>
<li>js的运行机制了解完之后, 我们再看这个题目,能分清那些是异步任务,那些是同步任务</li>
<li>wait函数肯定是一个异步函数了,在main函数内, 三个let赋值应该是什么任务;</li>
<li>用耳朵想都知道肯定是同步任务,直接在主线程里面被执行, 也就是同时执行了三个异步函数,将三个异步函数推进任务队列,</li>
<li>接下来就是await去等待执行的返回结果, 主线程执行完毕, 查看任务队列发现三个异步任务可以执行,推到主线程执行, 而对于await, 哪个耗时最长最后的时间就是耗时最长的时间.</li>
<li>— 所以 , 总的来说这三个wait函数的执行彼此之间没有依赖,这个异步函数的执行不需要一个异步函数执行完拿到的结果,所以可以采取下面的写法, 反之如果需要的话,那就采取上面的写法;</li>
</ul>
<p><em>补充一点:</em></p>
<h2 id="js的宏任务以及微任务"><a href="#js的宏任务以及微任务" class="headerlink" title="js的宏任务以及微任务:"></a>js的宏任务以及微任务:</h2><ul>
<li>宏任务: script主线程的代码  — setTimeout — setInterval — setImmediate — I/O操作 — UI渲染 — requestAniamationFrame</li>
<li>微任务: promise (原生) — MutationObserver —  process.nextTick() — mutation — Object.observe<br><img src="/2019/08/23/js-event/1.png" alt="Mou icon"></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="//likamoer.me/2019/08/20/three/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="likamoer">
      <meta itemprop="description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小新没蜡笔的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/20/three/" class="post-title-link" itemprop="url">认识THREE.JS</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-20 14:01:35 / 修改时间：14:04:41" itemprop="dateCreated datePublished" datetime="2019-08-20T14:01:35+08:00">2019-08-20</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="认识THREE-JS"><a href="#认识THREE-JS" class="headerlink" title="认识THREE.JS"></a>认识THREE.JS</h2><p><a href="https://threejs.org/" target="_blank" rel="noopener">THREE.js官网</a></p>
<p><img src="https://codropspz-tympanus.netdna-ssl.com/codrops/wp-content/uploads/2016/04/Animated3DScene_three-components.png" alt="Mou icon"><br><strong>上面这张图已经将three的大部分主题内容呈现了出来,那么three.js到底是个什么东西?</strong><br><em>接下来,切入正题<del>~</del></em></p>
<h6 id="一-认识THREE-js的第一步"><a href="#一-认识THREE-js的第一步" class="headerlink" title="一. 认识THREE.js的第一步"></a>一. 认识THREE.js的第一步</h6><ol>
<li>在了解three之前,我们必须来了解了解他的底层实现 — webGL</li>
</ol>
<ul>
<li>WebGL是基于OpenGL ES2.0的web标准(<em>有兴趣的可以自行查看,我的理解就是一个标准</em>),可以通过HTML5, canvas元素作为DOM接口访问</li>
<li>不了解OpenGL标准也没关系, 正如three.js不需要你了解OpenGL或者WebGL一样,只知道webGL是一个底层的标准就可以了</li>
</ul>
<ol start="2">
<li>那three.js是什么?</li>
</ol>
<ul>
<li>一个javascript的开源三维引擎</li>
<li>主流的3D绘图的js引擎</li>
<li>底层依靠webGL网页3D绘图标准</li>
<li>和webGL的关系就像Jq简化啦htmlDom操作一样, three.js可以简化webGL编程</li>
</ul>
<ol start="3">
<li>three.js究竟能够干什么?</li>
</ol>
<ul>
<li>three.js封装啦底层的图形接口,使得程序员在无需熟悉繁冗的图形学知识的情况下就能用简单的代码实现三维场景进行一个渲染</li>
<li>强大的灵活性,几乎不会有webGL实现three.js实现不了的情况,就算有你也可以使用webgl去实现而不会和之前的three代码产生冲突</li>
<li>除了webGL之外,three.js还提供了基于canvas, svg标签的渲染器,但是通常还是webGL能够实现的三维的场景比较真实,还原度比较高,效果比较好<h6 id="二-THREE的Hello-World"><a href="#二-THREE的Hello-World" class="headerlink" title="二. THREE的Hello World"></a>二. THREE的Hello World</h6></li>
</ul>
<ol>
<li>开发环境</li>
</ol>
<ul>
<li>three.js是javascript的库,所以可以像平常开发时,直接引入就可使用</li>
<li>但是three.js在使用皮肤,网格,文件下载等比较复杂的函数调用时就需要服务环境的搭载</li>
<li>所以最好就在开发文件下使用http-server开一个本地服务,这样加载本地图片作为皮肤,加载其他辅助类库文件就不会丢失</li>
</ul>
<ol start="2">
<li>three.js下载</li>
</ol>
<ul>
<li>在<a href="https://github.com/mrdoob/three.js/tree/master/build可以看到three.js和three.min.js两个文件,都可使用,自己拿捏" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/master/build可以看到three.js和three.min.js两个文件,都可使用,自己拿捏</a></li>
<li>可以直接在srcipt里面引入</li>
</ul>
<ol start="3">
<li><p>使用three.js编写hello world</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//创建渲染器，添加到dom当中, antialias（是否启用抗锯齿）  </span></span><br><span class="line">   <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer(&#123;<span class="attr">antialias</span>: <span class="literal">true</span>&#125;);  </span><br><span class="line">   <span class="comment">//设置渲染器的尺寸  </span></span><br><span class="line">   renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);  </span><br><span class="line">   <span class="comment">//将渲染器放置到页面当中  </span></span><br><span class="line">   <span class="built_in">document</span>.body.appendChild(renderer.domElement); </span><br><span class="line">   <span class="comment">//创建场景  </span></span><br><span class="line">   <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();  </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//创建相机，设置位置  </span></span><br><span class="line">   <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">45</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">1</span>, <span class="number">4000</span>);  </span><br><span class="line">   <span class="comment">//设置相机的位置  </span></span><br><span class="line">   camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>);  </span><br><span class="line">   <span class="comment">//创建一个平行光光源照射到物体上  </span></span><br><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>, <span class="number">1.5</span>);  </span><br><span class="line"><span class="comment">//设置平型光照射方向，照射方向为设置的点照射到原点  </span></span><br><span class="line">light.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line"><span class="comment">//将灯光放到场景当中  </span></span><br><span class="line">scene.add(light);</span><br><span class="line">       <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;<span class="attr">color</span>: red&#125;</span><br><span class="line">       <span class="comment">//创建一个立方体的几何体  </span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CubeGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);  </span><br><span class="line"><span class="comment">//将集合体和材质放到一个网格中  </span></span><br><span class="line"><span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(geometry, material); </span><br><span class="line"><span class="comment">//将立方体网格添加到场景中  </span></span><br><span class="line">       scene.add(cube); </span><br><span class="line">       <span class="comment">//声明一个判断是否旋转的变量  </span></span><br><span class="line"><span class="keyword">var</span> rotationBool = <span class="literal">true</span>;    </span><br><span class="line">       (<span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">           renderer.render(scene, camera);  </span><br><span class="line">           <span class="keyword">if</span> (rotationBool) &#123;  </span><br><span class="line">               cube.rotation.x += <span class="number">0.02</span>;  </span><br><span class="line">               cube.rotation.y += <span class="number">0.02</span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">           requestAnimationFrame(animate);  </span><br><span class="line">       &#125;)();  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    rotationBool = !rotationBool;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上代码会产生什么样的效果?</p>
<h6 id="三-THREE-js的主要成员"><a href="#三-THREE-js的主要成员" class="headerlink" title="三. THREE.js的主要成员"></a>三. THREE.js的主要成员</h6></li>
<li><p>scene – 场景(你可以将他想像成一个容器,一个空间,一块区域,一间房子)</p>
</li>
</ol>
<ul>
<li>scene的用处是什么那?空间,区域,房子是用来做什么 — 盛放,容纳,所以scene就是容纳你所要呈现的三维图的容器</li>
<li>在three.js中所加入的所有物体都是加到scene中的, 一般scene没有很复杂的操作,就在开始时实例化就可以啦</li>
<li>语法 – var scene = new THREE.Scene();</li>
</ul>
<ol start="2">
<li>render – 渲染器(可以理解为播放器,电视机,屏幕)</li>
</ol>
<ul>
<li><p>渲染器,顾名思义就是将你添加到scene里面的所有物体渲染出来的机器,既然是机器,那就存在分类</p>
</li>
<li><p>WebGLRenderer() – webGL渲染器: 就是使用webGL来渲染你所添加的内容</p>
<ol>
<li><p>支持参数的设置parameter(对象);</p>
</li>
<li><p>canvas: 绘制输出的画布,如果这里没有传参,默认将创建一个新的画布元素;</p>
</li>
<li><p>context: 用于呈现输出画布的上下文;</p>
</li>
<li><p>precision: 着色器的精度;可以选值为’highp’, ‘mediump’, ‘lowp’,三个值;</p>
</li>
<li><p>alpha: 画布是否包含透明缓冲区,默认为false;</p>
</li>
<li><p>premultipliedAlpha: 渲染器是否假设透明度已经预先叠乘啦;</p>
</li>
<li><p>antialias: 是否执行反锯齿;</p>
</li>
<li><p>stencil: 绘图缓冲区是否具有只少具有8位的钢网缓冲区;</p>
</li>
<li><p>preserveDrawingBuffer : 是否保存缓冲区,直到手动清除;</p>
</li>
<li><p>depth: 绘图缓冲区是否至少具有至少16位的深度缓冲区;</p>
<p>其他的参数具体看<a href="https://threejs.org/docs/index.html#api/en/renderers/WebGLRenderer" target="_blank" rel="noopener">https://threejs.org/docs/index.html#api/en/renderers/WebGLRenderer</a></p>
</li>
</ol>
</li>
<li><p>CSS2DRenderer() – CSS2DRenderer是 CSS3DRenderer的简化版本这个渲染器的作用是将基于html标签与3D对象结合</p>
<ol>
<li>例子: <a href="https://threejs.org/examples/#css2d_label" target="_blank" rel="noopener">https://threejs.org/examples/#css2d_label</a>;</li>
<li>方法: <ol>
<li>getSize() – 返回一个包含这个渲染器的宽度和高度的对象;</li>
<li>render(scene, camera) – 渲染参数里面的scene用参数camera;</li>
<li>setSize(width, height) – 重新设置宽度和高度.</li>
</ol>
</li>
</ol>
</li>
<li><p>CSS3DRenderer()  – 可以运用css3的转换样式,对Dom元素进行必要的3D转换</p>
<ol>
<li>例子: <a href="https://threejs.org/examples/#css3d_molecules" target="_blank" rel="noopener">https://threejs.org/examples/#css3d_molecules</a>;</li>
<li>方法: 同上.</li>
</ol>
</li>
<li><p>SVGRenderer() – 顾名思义,可以运用svg渲染;</p>
<pre><code>1. 优点: (1)可以使用svg般的矢量特点;(2)用css样式控制(3)有良好的访问性;
2. 缺点: (1)不支持shader自定义(2)不支持贴图(3)不支持阴影设置;
3. 方法:
      1. clear() -- 告诉浏览器删除所有用svgRenderer渲染的物体;
      2. render() -- 同上
      3. setClearColor(color, alpha) -- 设置清除的颜色和清除的透明度;
      4. setPrecision(precision) -- 设置被用来创造路径的数据的精度;
      5. setQuality() -- 设置渲染的质量,可能值有高有低;
      6. setSize() -- 同上.</code></pre></li>
</ul>
<ol start="3">
<li><p>camera 照相机 – 定义了三维空间到二维屏幕的投影方式,用’照相机’这一生活化的物体来理解投影的这一概念;针对投影方式的不同,照相机又分为正交投影照相机与透视投影照相机</p>
<ol>
<li><p>正交投影Orthography</p>
<p>THREE.OrthographicCamera(left, right, top, bottom, near, far)</p>
<p>这六个参数分别代表正交投影照相机拍摄的六个位置,六个面形成了一个长方体,成为视景体,只有在体内的物体才能显示在屏幕上;</p>
</li>
<li><p>透视投影PerspectiveCamera</p>
<p>THREE.PerspectiveCamera(fov, aspect, near, far)</p>
<p>fov是视景体的竖直方向上的张角,(角度制而非是弧度制)</p>
<p>aspect 等于 width(相机水平宽) / height(相机垂直高)</p>
<p>near 和 far 分别是相机到视景体的最近和最远的距离. </p>
</li>
</ol>
</li>
</ol>
<h6 id="四-THREE-js的其他成员"><a href="#四-THREE-js的其他成员" class="headerlink" title="四. THREE.js的其他成员"></a>四. THREE.js的其他成员</h6><ul>
<li><p>几何形状</p>
<ol>
<li>立方体<br>THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)<br>wdith x方向上的长度<br>height y方向上的长度<br>depth z方向上的长度<br>后面的三个参数: 分别为三个方向上的分段数 缺省值为1</li>
<li>平面<br>THREE.PlaneGeometry(width, height, widthSegments, heightSegments)<br>wdith x方向长度<br>height y方向上的长度<br>后面的参数: 两个方向的分段数(1)</li>
<li>球体<br>THREE.SphereGeometry(radius, segmentsWidth, phiStart, phiLength, thetaStart, thetaLength)<br>radius半径<br>segmentsWidth: 经度上的切片数<br>segmentsHeight 纬度上的切片数<br>phiStart: 经度开始的弧度<br>phiLength: 表示经度跨过得弧度<br>thetaStart: 表示纬度开始的弧度<br>thetaLength:表示纬度跨过的弧度 </li>
<li>圆形<br>THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)<br>参数介绍同上</li>
<li>圆柱体<br>THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)<br>radiusTop: 顶面的半径<br>radiusBottom: 地面的半径<br>hegiht: 圆柱体的高度<br>radiusSegments: 横向分段数<br>heightSegments: 纵向分段数<br>openEnded: 表示是否没有地面和顶面, 默认为false(表示有顶面和地面)</li>
<li>正四面体, 正八面体, 正二十面体<br>THREE.TetrahedronGeometry(radius, detail)<br>THREE.OctahedronGeometry(radius, detail)<br>THREE.IcosahedronGeometry(radius, detail)<br>radius: 半径<br>detail: 细节层次</li>
<li>圆环面(甜甜圈的形状)<br>THREE.TorusGeometry(radius, tube, radiusSegments, tubularSegments, arc)<br>radius: 圆环的半径<br>tube: 管道半径<br>radiusSegments: 半径分段数<br>tubularSegments: 管道分段数<br>arc: 圆环面的弧度(默认为Math.PI * 2) 一圈</li>
<li>圆环结(打了结的甜甜圈)<br>THREE.TorusKnotGeometry(radius, tube, radiusSegments, tubularSebmets, p, q, heightScale)<br>前四个参数同上<br>p, q是控制其样式的参数<br>hegihtScale是在z轴方向上的缩放</li>
</ol>
</li>
<li><p>文字形状</p>
<ol>
<li>THREE.TextGeometry(text, parameters)<br>text: 文字字符串<br>parameters: 一个对象,包含对文字样式的参数设置<br>size: 字号大小<br>height: 文字的厚度<br>curveSegments: 弧线分段数, 使得文字的曲线更加光滑<br>font: 字体<br>weight: 值为’normal’或者’bold’, 表示加粗<br>style: 值为’normal’或者’italics’, 表示是否斜体<br>bevelenabled: 是否使用倒角, 意为在边缘处斜切<br>bevelThickness: 倒角厚度;<br>bevelSize: 倒角宽度</li>
</ol>
</li>
<li><p>自定义形状</p>
<ol>
<li><p>THREE.Geometry()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化几何形状</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry();</span><br><span class="line"><span class="comment">// 设置顶点位置</span></span><br><span class="line"><span class="comment">// 顶部4顶点</span></span><br><span class="line">geometry.vertices.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">geometry.vertices.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">geometry.vertices.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">geometry.vertices.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// 底部4顶点</span></span><br><span class="line">geometry.vertices.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">-2</span>, <span class="number">0</span>, <span class="number">-2</span>));</span><br><span class="line">geometry.vertices.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">2</span>, <span class="number">0</span>, <span class="number">-2</span>));</span><br><span class="line">geometry.vertices.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">geometry.vertices.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置顶点连接情况</span></span><br><span class="line"><span class="comment">// 顶面</span></span><br><span class="line">geometry.faces.push(<span class="keyword">new</span> THREE.Face3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 底面</span></span><br><span class="line">geometry.faces.push(<span class="keyword">new</span> THREE.Face3(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// 四个侧面</span></span><br><span class="line">geometry.faces.push(<span class="keyword">new</span> THREE.Face3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">geometry.faces.push(<span class="keyword">new</span> THREE.Face3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>));</span><br><span class="line">geometry.faces.push(<span class="keyword">new</span> THREE.Face3(<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line">geometry.faces.push(<span class="keyword">new</span> THREE.Face3(<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>注意: </p>
<ol>
<li>new THREE.Vector3(-1, 2, 1)创建的是一个矢量,作为定点位置追加到geometry.vertices数组中</li>
<li>new THREE.Face3(0, 1, 2)创建一个面,三点连一个面,要放在geometry.faces数组中</li>
</ol>
</li>
</ol>
</li>
<li><p>材质</p>
<ol>
<li><p>材质是独立于物体定点信息的之外的与渲染效果相关的属性.那材质能干什么?</p>
<pre><code>1. 改变物体的颜色;
2. 纹理贴图;
3. 光照模式.</code></pre></li>
<li><p>基本材质</p>
<pre><code>THREE.MeshBasicMaterial(opt)

opt为属性的值的对象</code></pre><p>  常用的属性:</p>
<pre><code>visible: 是否可见 ,默认为true

side: 渲染面片正面或者是反面, 默认为正面THREE.FrontSide,可设置为反面的THREE.BackSide或者双面THREE.DoubleSide()

wireframe: 是否渲染线而非面, 默认为false

color: 十六进制RGB颜色, 

map: 使用纹理贴图</code></pre><p>对于基本材质,即使改变场景中的光源,材质也不会因为光源的改变而变化.</p>
</li>
<li><p>Lambert材质</p>
<pre><code>Lambert材质(MeshLambertMaterial) 是符合lambert光照模型的材质.Lambert光照模式的主要特点是只考虑漫反射而不是考虑镜面反射的效果,因而对于金属,镜子等需要镜面反射效果的物体就不适应,对于其他物体的漫反射效果都是适用的

1. new THREE.MeshLambertMaterial({})
2. color是用来表现材质对散射光的反射能力，也是最常用来设置材质颜色的属性。除此之外，还可以用ambient和emissive控制材质的颜色
3. ambient表示对环境光的反射能力，只有当设置了AmbientLight后，该值才是有效的，材质对环境光的反射能力与环境光强相乘后得到材质实际表现的颜色。
4. emissive是材质的自发光颜色，可以用来表现光源的颜色.</code></pre></li>
<li><p>Phong材质</p>
<pre><code>Phong材质(MeshPhongMaterial)是符合Phong光照模型的材质.和lambert不同的是,Phong模型考虑了镜面反射的效果,对于金属,镜面的效果的表现尤为合适

new THREE.MeshPhongMaterial({})</code></pre></li>
<li><p>法向材质</p>
<pre><code>法向材质可以将材质的颜色设置为其法向量的方向,有时候对于调试很有帮助

new THREE.MeshNormalMaterial()

材质的颜色与照相机与该物体的角度相关</code></pre></li>
<li><p>材质的纹理贴图</p>
<pre><code>之前使用的材质都是单一颜色的,那怎么用图像作为材质那?

var texture = new THREE.ImageUtils.loadTexture(&apos;路径&apos;)

然后将材质的map设置为

var material = new THREE.MeshLambertMaterial({

  map: texture

})</code></pre></li>
</ol>
</li>
</ul>
<ul>
<li><p>网格</p>
<p>几何 + 材质 = 物体</p>
<p>物体有哪几种类型:</p>
<p>网格 线段 骨骼 粒子系统 等</p>
<p>几何确定了物体的顶点信息, 位置</p>
<p>材质确定了物体的颜色, 纹理等</p>
<ol>
<li><p>创建网格</p>
<p>new Mesh(geometry, material)</p>
</li>
<li><p>修改属性</p>
<p>创建网格之后也可以修改网格的材质</p>
<p>mesh.material = …</p>
<p>场景中显示最后修改后材质的网格</p>
</li>
<li><p>位置, 缩放, 旋转</p>
<p>这三个属性是物体常用属性,在THREE里面顶层对象都是THREE.Object3D所以mesh也包含这三个属性,并且可以改变,进行动画的设计</p>
</li>
</ol>
</li>
<li><p>光与影</p>
<p>图像渲染的丰富效果很大程度上也要归功于光与影的利用。真实世界中的光影效果非常复杂，但是其本质——光的传播原理却又是非常单一的，这便是自然界繁简相成的又一例证。为了使计算机模拟丰富的光照效果，人们提出了几种不同的光源模型（环境光、平行光、点光源、聚光灯等），在不同场合下组合利用，将能达到很好的光照效果.</p>
<ol>
<li><p>环境光</p>
<p>环境光是指场景整体的光照效果,是由于场景内若干光源的多次反射形成的亮度一致的效果,通常用来为整个场景来提供一个基础的亮度.因此环境光没有明确的光源位置,在各处形成的光的强度也是一样的.</p>
<p>new THREE.AmbientLight(0x000000) —&gt; 直接填颜色值就好</p>
<p>如果场景中没有添加物体的话,只添加了环境光,那么还是一片黑色.</p>
<p>注意: 环境光通常设置成白色或者是灰色 —- 为什么?</p>
<p>因为不透明物体的颜色其实是其反射光的颜色,而材质的ambient属性表示的是物体反射环境光的能力.比如物体的材质ambient属性是红色 , 而环境光的颜色也是红色,那么此时的红色的通道就是0,所以该物体不会反射任何颜色,渲染为黑色.</p>
</li>
<li><p>点光源</p>
<p>点光源是不计光源的大小,可以看做是一个点发出的光源,点光源照到不同物体表面的亮度是线性递减的,因此,离点光源越远的物体会显得越暗.</p>
<p>var light = new THREE.PointLight(hex, intensity, distance)</p>
<p>颜色, 光亮强度(1), 最远照射距离(0) — 参数</p>
<p>点光源是有位置朝向的,在创建完光源实例后要进行位置设置</p>
<p>light.position.set(0, 0, 0)</p>
<p>注意: 点光源在每个物体的三角平面的亮度是不一样的,要进行插值运算,但是这是three内部引擎该做的工作.</p>
</li>
<li><p>平行光</p>
<p>举个栗子: 太阳光就是最常见的平行光</p>
<p>这是因为相对于地球上的物体的尺度而言,太阳离我们的距离够远.对于任意平行的平面,平行光照射的亮度都是相同的,而与平面所在的位置无关.</p>
<p>var light = new THREE.DirectionLight(hex, intensity)</p>
<p>颜色值, 光的强度(1)</p>
<p>light.position.set(2, 5, 6)</p>
<p>注意: 此时设置的光源位置并不意味着所有光源都是从(2, 5, 6)发出的(如果是的话,那就和点光源没什么区别啦),而是意味着平行光将以矢量(-2, -5, -6)的方向照射到所有的平面.因此平面的亮度与平面的位置无关,而只与平面的法向量相关.只要平面是平行的,那么得到的光照也是相同的.</p>
</li>
<li><p>聚灯光</p>
<p>聚灯光其实是一种特殊的点光源,它能够朝着一个方向上投射灯光线.聚灯光投射出的类似圆锥形的光线,这与我们现实中看到的聚光灯是一致的.</p>
<p>var light = new THREE.SpotLight(hex, intensity, distance, angle, exponent)</p>
<p>相比较点光源,多了angle,exponent两个参数;angle是聚灯光的张角(Math.PI / 3),最大值为Math.PI / 2,exponent是光强在偏离target的衰减指数(target需要在之后定义,缺省值为(0, 0, 0)), 缺省值为10.</p>
<p>light.position.set(10, 10, 10)</p>
<p>除了设置灯光的位置意外,还要设置其照向的目标点</p>
<p>light.target.position.set(0, 0, 0)</p>
<p>target也还可以设置为物体.</p>
</li>
</ol>
</li>
</ul>
<p>​          </p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="//likamoer.me/2019/08/20/mapbox/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="likamoer">
      <meta itemprop="description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小新没蜡笔的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/20/mapbox/" class="post-title-link" itemprop="url">认识mapbox-g</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-20 14:01:35 / 修改时间：14:04:15" itemprop="dateCreated datePublished" datetime="2019-08-20T14:01:35+08:00">2019-08-20</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="认识mapbox-gl"><a href="#认识mapbox-gl" class="headerlink" title="认识mapbox-gl:"></a>认识mapbox-gl:</h2><p>官网API: <a href="https://docs.mapbox.com/mapbox-gl-js/api" target="_blank" rel="noopener">https://docs.mapbox.com/mapbox-gl-js/api</a></p>
<blockquote>
<p>Mapbox GL JS是一个JavaScript库，它使用WebGL从矢量贴图和Mapbox样式中呈现交互式地图。它是Mapbox GL生态系统的一部分，其中包括Mapbox Mobile，这是一个用c++编写的兼容的渲染器，具有桌面和移动平台的绑定。要了解我们的团队正在开发哪些新特性，请查看我们的路线图。</p>
</blockquote>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="//likamoer.me/2019/08/20/deck-gl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="likamoer">
      <meta itemprop="description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小新没蜡笔的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/20/deck-gl/" class="post-title-link" itemprop="url">认识deck.gl</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-20 14:01:35" itemprop="dateCreated datePublished" datetime="2019-08-20T14:01:35+08:00">2019-08-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-23 15:14:23" itemprop="dateModified" datetime="2019-08-23T15:14:23+08:00">2019-08-23</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>copyright: true</p>
<h2 id="认识deck-gl"><a href="#认识deck-gl" class="headerlink" title="认识deck.gl"></a>认识deck.gl</h2><p><em>来自官方的解释:</em></p>
<blockquote>
<p>deck.gl的设计目的是简化大数据集的可视化。它使用户能够通过现有层的组合以有限的努力快速获得令人印象深刻的可视化结果，同时为将基于WebGL的高级可视化打包为可重用的JavaScript层提供了完整的体系结构。</p>
</blockquote>
<p><em>简要概述:</em></p>
<p>deck.gl的基本思想是渲染层的叠加 , 通常是渲染在地图上,但不总是;</p>
<p>deck.gl面对的机遇与挑战:</p>
<ol>
<li>处理大数据集和性能更新优化;</li>
<li>交互式处理 例如拾取事件(picking);</li>
<li>地图投影和与基础地图的集成;</li>
<li>经过验证的、经过良好测试的层的目录;</li>
<li>易于创建新层或自定义现有层.</li>
</ol>
<p><em>生态系统:</em></p>
<p>deck.gl是vis.gl框架的主要框架之一;与许多框架进行并行开发,如下;</p>
<ul>
<li>luma.gl - 一个通用的WebGL库，旨在与原始的WebGL API和其他WebGL库(尽可能)互操作。特别是 , luma.gl不声明WebGL上下文的所有权，并且可以使用任何提供的上下文，包括应用程序或其他WebGL库创建的上下文;</li>
<li>react-map-gl - 一个React包装周围的Mapbox GL与deck.gl无缝工作(通俗点说就是mapbox-gl的react版本);</li>
<li>nebula.gl - 一个有着高性能的deck.gl的编辑框架;</li>
</ul>
<p><em>如何使用:</em></p>
<ol>
<li><p>安装: npm install deck.gl –save</p>
</li>
<li><p>也可以直接下载官方栗子:</p>
<p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:uber/deck.gl.git</p>
<p>cd deck.gl/examples/…(你想看的栗子目录下)</p>
<p>npm install</p>
<p>npm start  —- (运行)</p>
<p>这样栗子就运行起来啦!!!</p>
</li>
</ol>
<p><em>纯js使用deck.gl:</em></p>
<ul>
<li><p>deck.gl的核心库和层对React或Mapbox gl没有依赖关系，可以被任何JavaScript应用程序使用。</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Deck&#125; <span class="keyword">from</span> <span class="string">'@deck.gl/core'</span>; <span class="comment">// 引入deck的核心模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;GeoJsonLayer&#125; <span class="keyword">from</span> <span class="string">'@deck.gl/layers'</span>; <span class="comment">// 引入需要显示的层,有很多层,后续讲到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// source: Natural Earth http://www.naturalearthdata.com/ via geojson.xyz</span></span><br><span class="line"><span class="keyword">const</span> GEOJSON =</span><br><span class="line">  <span class="string">'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_admin_1_states_provinces_shp.geojson'</span>; <span class="comment">// 要展示的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INITIAL_VIEW_STATE = &#123;</span><br><span class="line">  latitude: <span class="number">40</span>, <span class="comment">// 经度</span></span><br><span class="line">  longitude: <span class="number">-100</span>, <span class="comment">// 纬度</span></span><br><span class="line">  zoom: <span class="number">3</span>, <span class="comment">// 缩放级别</span></span><br><span class="line">  bearing: <span class="number">30</span>, <span class="comment">// 轴承指数</span></span><br><span class="line">  pitch: <span class="number">30</span> <span class="comment">// 倾斜角度 0 - 90</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deck = <span class="keyword">new</span> Deck(&#123;</span><br><span class="line">  width: <span class="string">'100%'</span>, <span class="comment">// 设置deck范围</span></span><br><span class="line">  height: <span class="string">'100%'</span>, <span class="comment">// 高</span></span><br><span class="line">  initialViewState: INITIAL_VIEW_STATE, <span class="comment">// 定义初始化页面的deck在地图上的位置,视角</span></span><br><span class="line">  controller: <span class="literal">true</span>, <span class="comment">// 将控制器打开</span></span><br><span class="line">  layers: [ <span class="comment">// 需要显示的层</span></span><br><span class="line">    <span class="keyword">new</span> GeoJsonLayer(&#123; <span class="comment">// 将显示的层new出实例</span></span><br><span class="line">      data: GEOJSON, <span class="comment">// 展示的数据</span></span><br><span class="line">      stroked: <span class="literal">true</span>, <span class="comment">// 线</span></span><br><span class="line">      filled: <span class="literal">true</span>, <span class="comment">// 填充</span></span><br><span class="line">      lineWidthMinPixels: <span class="number">2</span>, <span class="comment">// 线的最小宽度</span></span><br><span class="line">      opacity: <span class="number">0.4</span>, <span class="comment">// 线的透明度</span></span><br><span class="line">      getLineColor: <span class="function"><span class="params">()</span> =&gt;</span> [<span class="number">255</span>, <span class="number">100</span>, <span class="number">100</span>], <span class="comment">// 设置线的颜色</span></span><br><span class="line">      getFillColor: <span class="function"><span class="params">()</span> =&gt;</span> [<span class="number">200</span>, <span class="number">160</span>, <span class="number">0</span>, <span class="number">180</span>] <span class="comment">// 设置填充的颜色</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// For automated test cases</span></span><br><span class="line"><span class="comment">/* global document */</span></span><br><span class="line"><span class="built_in">document</span>.body.style.margin = <span class="string">'0px'</span>;</span><br></pre></td></tr></table></figure>

<p>@deck.gl/core是deck的一个子模块 , 不包含任何响应依赖项的gl.</p>
</li>
<li><p>上面的代码实例就是使用一个纯js的deck.gl模块库的完整示例. es6的写法;</p>
</li>
<li><p>在script中如何引入?</p>
<script src="https://unpkg.com/deck.gl@latest/deckgl.min.js"></script>

<script src="https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js"></script>

<link href="https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css">

<p>不仅要引入deck.gl,而且还要引入mapbox-gl的js和css文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><em>结合React使用:</em></p>
<p>这也是官方推荐使用的方式;</p>
<p>虽然不是直接基于React, deck.gl从头设计到使用基于React的应用程序。deck.gl层自然适合React的组件渲染流和基于flux/redux的应用。当您重新运行您的正常JSX或React组件时，gl层将被高效地重新加载。</p>
<ul>
<li><p>结合React使用Deck.gl，只需导入DeckGL React组件，并将其作为另一个组件的子组件呈现，然后传入deck列表。deck.gl层作为属性。</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// app.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>; <span class="comment">// 结合React使用,先引入React</span></span><br><span class="line"><span class="keyword">import</span> DeckGL, &#123;LineLayer&#125; <span class="keyword">from</span> <span class="string">'deck.gl'</span>; <span class="comment">// 引入DeckGL 和需要使用的层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Viewport settings</span></span><br><span class="line"><span class="comment">// 初始化的页面角度位置</span></span><br><span class="line"><span class="keyword">const</span> viewState = &#123;</span><br><span class="line">  longitude: <span class="number">-122.41669</span>, <span class="comment">// 经度</span></span><br><span class="line">  latitude: <span class="number">37.7853</span>, <span class="comment">// 纬度</span></span><br><span class="line">  zoom: <span class="number">13</span>, <span class="comment">// 缩放</span></span><br><span class="line">  pitch: <span class="number">0</span>, <span class="comment">// 倾斜角度</span></span><br><span class="line">  bearing: <span class="number">0</span> <span class="comment">// 轴承</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data to be used by the LineLayer</span></span><br><span class="line"><span class="comment">// 创建数据 源位置 --- 目标位置</span></span><br><span class="line"><span class="keyword">const</span> data = [&#123;<span class="attr">sourcePosition</span>: [<span class="number">-122.41669</span>, <span class="number">37.7853</span>], <span class="attr">targetPosition</span>: [<span class="number">-122.41669</span>, <span class="number">37.781</span>]&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeckGL react component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> layers = [</span><br><span class="line">      <span class="keyword">new</span> LineLayer(&#123;<span class="attr">id</span>: <span class="string">'line-layer'</span>, data&#125;) <span class="comment">// 初始化层</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;DeckGL viewState=&#123;viewState&#125; layers=&#123;layers&#125; /&gt; <span class="comment">// 设置组件</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deck.gl的重要伙伴 —- react-map-gl。它是Mapbox的一个React包装器，可以共享相同的web mercator viewport设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// app.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> DeckGL, &#123;LineLayer&#125; <span class="keyword">from</span> <span class="string">'deck.gl'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;StaticMap&#125; <span class="keyword">from</span> <span class="string">'react-map-gl'</span>; <span class="comment">// 引入react-map-gl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set your mapbox access token here</span></span><br><span class="line"><span class="keyword">const</span> MAPBOX_ACCESS_TOKEN = <span class="string">'MAPBOX_ACCESS_TOKEN'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial viewport settings</span></span><br><span class="line"><span class="keyword">const</span> initialViewState = &#123;</span><br><span class="line">  longitude: <span class="number">-122.41669</span>,</span><br><span class="line">  latitude: <span class="number">37.7853</span>,</span><br><span class="line">  zoom: <span class="number">13</span>,</span><br><span class="line">  pitch: <span class="number">0</span>,</span><br><span class="line">  bearing: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data to be used by the LineLayer</span></span><br><span class="line"><span class="keyword">const</span> data = [&#123;<span class="attr">sourcePosition</span>: [<span class="number">-122.41669</span>, <span class="number">37.7853</span>], <span class="attr">targetPosition</span>: [<span class="number">-122.41669</span>, <span class="number">37.781</span>]&#125;];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> layers = [</span><br><span class="line">      <span class="keyword">new</span> LineLayer(&#123;<span class="attr">id</span>: <span class="string">'line-layer'</span>, data&#125;)</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;DeckGL</span><br><span class="line">        initialViewState=&#123;initialViewState&#125;</span><br><span class="line">        controller=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">        layers=&#123;layers&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;StaticMap mapboxApiAccessToken=&#123;MAPBOX_ACCESS_TOKEN&#125; /&gt; ---- 在这加入react-map-gl的map组件</span><br><span class="line">      &lt;<span class="regexp">/DeckGL&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于react-map-gl:</p>
<p>如示例中所示，DeckGL React组件作为React组件的子组件(如使用类似于deck的参数显示地图的React -map-gl)尤其有效。gl视口(即纬度，经度，缩放等)。在这个配置中，你的deck.gl层将在底层地图上呈现一个完全同步的地理空间覆盖。</p>
</li>
</ul>
<p><em>通过层可视化数据:</em></p>
<ol>
<li><p>渲染单个层</p>
<ul>
<li><p>deck.gl的设计允许您获取任何可以关联位置的数据，并使用deck轻松地在地图上呈现这些数据。关于deck.gl层,只需实例化该层的类，并传入一组属性，其中包括数据本身，以及该层用于构建可视化的一些访问器和属性;</p>
</li>
<li><p>属性是允许控制层如何呈现数据的值;</p>
</li>
<li><p>访问器是用来描述层应该如何提取各种值的函数。</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;DeckGL layers=&#123;[</span><br><span class="line">  <span class="keyword">new</span> ArcLayer(&#123;<span class="attr">data</span>: ...&#125;)</span><br><span class="line">]&#125; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>渲染多个层</p>
<ul>
<li><p>deck.gl允许使用相同或不同的数据集呈现多个层。只需提供层实例和deck的数组。deck.gl将按顺序渲染它们(并处理悬停单击时的交互性等)。</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;DeckGL layers=&#123;[</span><br><span class="line">  <span class="keyword">new</span> PathLayer(&#123;<span class="attr">data</span>: ...&#125;),</span><br><span class="line">  <span class="keyword">new</span> LineLayer(&#123;<span class="attr">data</span>: ...&#125;),</span><br><span class="line">  <span class="keyword">new</span> ArcLayer(&#123;<span class="attr">data</span>: ...&#125;),</span><br><span class="line">]&#125; /&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p><em>Deck.gl中主要的类:</em></p>
<ol>
<li><p>Deck</p>
<ul>
<li><input checked disabled type="checkbox"> <p>Deck是一个使用Deck的类。deck.gl层实例和viewport参数，将这些层呈现为透明覆盖，并处理事件;</p>
</li>
<li><input checked disabled type="checkbox"> <p>在使用React-map-gl中不需要此类的参加,而在纯js开发中,此类便是不可缺少的;</p>
</li>
<li><input checked disabled type="checkbox"> <p>怎么用?</p>
</li>
<li><input checked disabled type="checkbox"> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Basic standalone use</span></span><br><span class="line"><span class="keyword">import</span> &#123;Deck, ScatterplotLayer&#125; <span class="keyword">from</span> <span class="string">'deck.gl'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">viewState, data</span>) =&gt;</span> (</span><br><span class="line">  <span class="comment">// 创建一个新的Deck类 --- 生成一个画布</span></span><br><span class="line">  <span class="keyword">const</span> deck = <span class="keyword">new</span> Deck(&#123;</span><br><span class="line">	<span class="comment">// 加入层    </span></span><br><span class="line">    layers: [<span class="keyword">new</span> ScatterplotLayer(&#123;data&#125;)]</span><br><span class="line">  &#125;);</span><br><span class="line">  deck.setProps(&#123;viewState&#125;);</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Deck类的属性:</p>
<ol>
<li><p>width: 画布的宽(Number)</p>
</li>
<li><p>height: 画布的高(Number)</p>
</li>
<li><p>layers: 要渲染的层的集合 — 将要渲染的层放到一个数组里面,进行逐个渲染(Array)</p>
</li>
<li><p>layersFilter: 接收一个函数,函数的参数为layer, viewport, isPicking,用来过滤层,调整视口,控制是否发生拾取事件,所有层在渲染之前都会走这个函数,所以层的显隐可以在这里实现(Function: ({layers, viewport, isPicking}) =&gt; {….})</p>
</li>
<li><p>getCursor:  接收一个函数,来检索游标类型的自定义回调(Function: ({isDragging}) =&gt; isDragging ? ‘grabbing’ : ‘grab’)</p>
</li>
<li><p>views: 单个视图或视图实例的数组(可选地与Viewport实例混合，尽管后者是不推荐的)。如果没有提供，将创建一个MapView。如果提供了空数组，则不会显示任何视图。(Array)</p>
</li>
<li><p>viewState: 地理空间视图状态(Object)</p>
<ul>
<li><p>latitude: 经度(Number)</p>
</li>
<li><p>longitude: 纬度(Number)</p>
</li>
<li><p>zoom: 缩放程度(Number)</p>
</li>
<li><p>bearing: 轴承程度(Number)</p>
</li>
<li><p>pitch: 倾斜角度(Number: 0 - 90)</p>
<p>可以通过改变viewState的参数值来改变画布实例的角度位置</p>
</li>
</ul>
</li>
<li><p>initialViewState: 如果提供了initialViewState, Deck组件将使用内部状态跟踪来自任何附加控制器的视图状态更改，initialViewState作为其初始视图状态。(Object: 属性和viewState一样)</p>
</li>
<li><p>controller: 视窗互动选项，例如:平移，旋转和缩放与鼠标，触摸和键盘。如果使用默认视图(即单个MapView)，这是定义与视图道具交互的简写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Deck(&#123;</span><br><span class="line">  ...</span><br><span class="line">  views: [<span class="keyword">new</span> MapView(&#123;<span class="attr">controller</span>: <span class="literal">true</span>&#125;)]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 上面写法和下面是一样的</span></span><br><span class="line"><span class="keyword">new</span> Deck(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// views: undefined</span></span><br><span class="line">  controller: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其值有以下几种类型:</p>
<ul>
<li>null or false: 默认不启动控制器</li>
<li>true: 默认启动默认控制器</li>
<li>Controller: 使用默认选项启动所提供的控制器。必须是MapController的子类。</li>
<li>默认为null</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Deck类的配置属性:</p>
<ol>
<li>id(String): Canvas ID允许在CSS中定制样式;</li>
<li>style(Object): deckgl-canvas的Css样式;</li>
<li>pickingRadius(Number): 在选择时指针周围要包括的额外像素。当呈现的对象难以定位时，这是很有帮助的，例如不规则形状的图标、小的移动圆圈或触摸交互。默认为0。</li>
<li>useDevicePixels(Boolean):  如果为真，设备的全分辨率将用于渲染，这个值可以在每帧中改变，比如在屏幕之间移动窗口或改变浏览器的缩放级别。默认为真,但是一般都将其设置为false,因为这个会非常消耗性能,除非机器的性能足够高.</li>
<li>gl(Object): gl的上下文,如果不提供将会自动创建;</li>
</ol>
</li>
<li><p>Deck类的回调函数:</p>
<ol>
<li>onWebGLInitialized(Function: (gl) =&gt; {….})一旦webGL上下文被初始化,就会被调用;</li>
<li>onViewStateChange(Function: (viewState) -&gt; {….}): 当用户改变画布角度时调用.例如使用鼠标拖曳, 键盘控制等.</li>
<li>onLayerHover(Function: ): 当指针下的对象发生变化时调用。在鼠标悬浮在物体之上发生的回调;<ul>
<li>参数: info, pickedInfos, event</li>
<li>info: 在坐标中最顶层选择的info对象，在没有选择对象时为null;</li>
<li>pickedInfos: 所有受影响的可选层的信息对象数组。</li>
<li>event: 原始MouseEvent对象</li>
</ul>
</li>
<li>onLayerClick(Function): 当指针点击时发生的回调.参数同Hover回调</li>
<li>onDragStart, onDrag, onDragEnd(Function): 拖曳开始, 拖曳中, 拖曳结束<ul>
<li>参数: info, event 同Hover事件的参数</li>
</ul>
</li>
<li>onLoad(Function): 在创建gl上下文和Deck组件(ViewManager、LayerManager等)之后调用一次。可用于触发视口转换;</li>
</ol>
</li>
<li><p>Deck类的方法:</p>
<ol>
<li><p>finalize: 立即释放与此对象关联的资源(而不是等待垃圾收集)。</p>
<p>deck.finalize();</p>
</li>
<li><p>setProps: 更新属性.</p>
<p>deck.setProps({…..})</p>
</li>
<li><p>pickObject: 在给定的屏幕坐标上获取最近的可选可见对象.</p>
<p>deck.pickObject({x, y, radius, layerIds})</p>
<p>x: x位置(像素)</p>
<p>y: y位置(像素)</p>
<p>radius: 以像素为单位的公差半径</p>
<p>layerIds: 要查询的层id的列表。如果没有指定，则查询所有可选的和可见的层</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Layer:  Layer类是所有deck的基类。gl层，它提供了许多在所有层中可用的基本属性。</p>
<ul>
<li><p>静态成员</p>
<ol>
<li>layerName: 这个静态属性应该包含层的名称，通常是层的类的名称(不能在缩小的代码中可靠地自动推导)。它用作默认的层id以及调试和分析.</li>
<li>defaultProps: 所有deck.gl层定义一个defaultProps静态成员，列出它们的道具和默认值。在层实例构建过程中，使用defaultProps可以提高代码的可读性和性能。</li>
</ol>
</li>
<li><p>构造函数</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Layer(.<span class="built_in">..props</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基础属性</p>
<ol>
<li>id(String): 静态属性 — 在给定的时间内，id必须在所有层之间是唯一的。id的默认值是层的“name”。如果一个特定层类型的多个实例同时存在，它们必须拥有deck的不同id字符串。gl来正确区分它们。</li>
<li>data(String|Iterable|Promise): deck.gl层通常期望数据支柱的值是一个JavaScript数组。也可以使用任何实现iterable协议的对象.数组,伪数组都可以.<ul>
<li>如果提供字符串，deck。gl将尝试将其作为URL加载，将其解析为JSON，然后使用预期的结果JavaScript数组作为其数据支柱</li>
<li>如果是Promise函数，deck.gl将使用resolve解析值作为其数据支柱。</li>
</ul>
</li>
<li>visible(Boolean): 层是否可见。在大多数情况下，建议使用可见道具来控制图层的可见性，而不是使用条件渲染</li>
<li>opacity(Number): 图层的不透明度;</li>
</ol>
</li>
<li><p>交互属性</p>
<ol>
<li><p>pickable(Boolean, default: false): 层是否响应鼠标指针选择事件。</p>
</li>
<li><p>onHover(Function): 当鼠标进入/离开此deck.gl层的对象时，将调用此回调,具有以下参数:</p>
<ul>
<li>info: 此时鼠标下的信息</li>
<li>event: 事件对象</li>
</ul>
</li>
<li><p>onClick(Function): 当鼠标点击此deck.gl层的对象时,将调用此回调,具有以下参数: 同onHover</p>
</li>
<li><p>onDragStart, onDrag, onDragEnd同Deck回调事件;</p>
</li>
<li><p>highlightColor(Array, [0, 0, 128, 128])</p>
<ul>
<li>RGBA颜色用于渲染突出显示的对象。当指定3 component (RGB)数组时，alpha使用默认值255。</li>
</ul>
</li>
<li><p>highlightedObjectIndex(Integer, -1)</p>
<ul>
<li>当提供一个有效值时，对应的对象(实例渲染中的一个实例或具有相同拾取颜色的一组原语)将使用highlightColor高亮显示。</li>
</ul>
</li>
<li><p>autoHighLight(Boolean, false)</p>
<ul>
<li><p>当为true时，鼠标指针指向的当前对象(悬停在其上时)用highlightColor高亮显示。</p>
<p>要求picable为真。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>坐标系统的属性 —- 通常只在应用程序希望使用非Web Mercator投影经纬度的坐标时使用</p>
<ol>
<li>coordinateSystem(Number): 指定如何对层位置和偏移量进行地理解释。</li>
<li>coordinateOrigin([Number, Number]): 将coordinateSystem设置为coordinate_system . meter_offset时需要。</li>
<li>wrapLongitude(Boolean, false): 自动将纵向缠绕在第180个反物质上，以获得当前视区的最佳可视性。</li>
<li>modelMatrix(Number[16]):一个可选的4x4矩阵，它被乘进着色器项目GLSL函数和Viewport的项目和非项目JavaScript函数使用的仿射投影矩阵</li>
</ol>
</li>
<li><p>数据属性</p>
<ol>
<li>dataComparator(Function): 这个支持使用自定义比较函数对数据支持进行比较。使用旧数据和新数据对象调用compare函数，如果它们进行相等的比较，则期望返回true。</li>
<li>numInstances(Number): deck.gl通过计算数据中对象的数量，自动从数据支柱中获取绘图实例的数量。但是，开发人员可能希望使用此道具手动覆盖它。</li>
<li>updateTriggers(Object): 调用getColor和getPosition等访问器来检索第一次添加层时的颜色和位置。从那以后，为了最大化性能，deck。gl不会重新计算颜色或位置，除非通过浅比较更改数据支柱。</li>
</ol>
</li>
</ul>
</li>
<li><p>其他衍生Layer层的实例</p>
<ol>
<li>ArcLayer: 弧线层呈现向上的弧线，连接源点和目标点对，指定为纬度/经度坐标。</li>
</ol>
<ul>
<li><p>怎么使用?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DeckGL, &#123;ArcLayer&#125; <span class="keyword">from</span> <span class="string">'deck.gl'</span>;</span><br><span class="line"><span class="comment">// 从deck.gl里面引出弧线层类</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123;data, viewport&#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 拿到数据,匹配格式</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Data format:</span></span><br><span class="line"><span class="comment">   * [</span></span><br><span class="line"><span class="comment">   *   &#123;</span></span><br><span class="line"><span class="comment">   *     inbound: 72633,</span></span><br><span class="line"><span class="comment">   *     outbound: 74735,</span></span><br><span class="line"><span class="comment">   *     from: &#123;</span></span><br><span class="line"><span class="comment">   *       name: '19th St. Oakland (19TH)',</span></span><br><span class="line"><span class="comment">   *       coordinates: [-122.269029, 37.80787]</span></span><br><span class="line"><span class="comment">   *     &#125;,</span></span><br><span class="line"><span class="comment">   *     to: &#123;</span></span><br><span class="line"><span class="comment">   *       name: '12th St. Oakland City Center (12TH)',</span></span><br><span class="line"><span class="comment">   *       coordinates: [-122.271604, 37.803664]</span></span><br><span class="line"><span class="comment">   *   &#125;,</span></span><br><span class="line"><span class="comment">   *   ...</span></span><br><span class="line"><span class="comment">   * ]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="comment">// 创建弧线层实例</span></span><br><span class="line">  <span class="keyword">const</span> layer = <span class="keyword">new</span> ArcLayer(&#123;</span><br><span class="line">    id: <span class="string">'arc-layer'</span>, <span class="comment">// 定义名称 -- 方便之后更容易找到此层并操作</span></span><br><span class="line">    data, <span class="comment">// 加载数据</span></span><br><span class="line">    pickable: <span class="literal">true</span>, <span class="comment">// 允许发生拾取事件</span></span><br><span class="line">    getStrokeWidth: <span class="number">12</span>, <span class="comment">// 设置弧线的宽度</span></span><br><span class="line">    getSourcePosition: <span class="function"><span class="params">d</span> =&gt;</span> d.from.coordinates, <span class="comment">// 设置来源点的位置</span></span><br><span class="line">    getTargetPosition: <span class="function"><span class="params">d</span> =&gt;</span> d.to.coordinates, <span class="comment">// 设置目标点的位置</span></span><br><span class="line">    getSourceColor: <span class="function"><span class="params">d</span> =&gt;</span> [<span class="built_in">Math</span>.sqrt(d.inbound), <span class="number">140</span>, <span class="number">0</span>], <span class="comment">// 设置弧线来源点一边的弧线颜色</span></span><br><span class="line">    getTargetColor: <span class="function"><span class="params">d</span> =&gt;</span> [<span class="built_in">Math</span>.sqrt(d.outbound), <span class="number">140</span>, <span class="number">0</span>], <span class="comment">// 设置弧线目标点的弧线颜色</span></span><br><span class="line">    onHover: <span class="function">(<span class="params">&#123;object, x, y&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> tooltip = <span class="string">`<span class="subst">$&#123;object.<span class="keyword">from</span>.name&#125;</span> to <span class="subst">$&#123;object.to.name&#125;</span>`</span>; <span class="comment">// 在鼠标悬浮的时候产生的回调函数</span></span><br><span class="line">      <span class="comment">/* Update tooltip</span></span><br><span class="line"><span class="comment">         http://deck.gl/#/documentation/developer-guide/adding-interactivity?					section=example-display-a-tooltip-for-hovered-object</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">DeckGL</span> &#123;<span class="attr">...viewport</span>&#125; <span class="attr">layers</span>=<span class="string">&#123;[layer]&#125;</span> /&gt;</span>); // 最后在组件中渲染该层实例</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>属性: 从所有的基础层类(Layer)继承属性.</p>
</li>
<li><p>渲染时的配置项:</p>
<ol>
<li>fp64(Boolean, false): 是否应该在高精度64位模式下渲染该层。注意自deck.gl v6.1，默认的32位投影使用一种混合模式，这种模式与64位精度匹配，性能显著提高.</li>
<li>widthScale(Number, 1): 每个弧的宽度的比例因子。如果将属性设置为Math.pow(2,viewport.zoom - 12)宽度保持不变，对应当前的zoom level和zoom level 12时1像素的宽度。还可以使用此属性限制弧的最小大小宽度.</li>
</ol>
</li>
<li><p>数据访存器:</p>
<ol>
<li><p>getSourcePosition(Function): 方法 — 来检索每个对象的源位置。</p>
</li>
<li><p>getTargetPosition(Function): 方法 — 来检索每个对象的目的位置.</p>
</li>
<li><p>getSourceColor(Function|Array, [0, 0, 0, 255]): 方法 — 检索位置颜色.</p>
<ul>
<li>如果是Array,直接返回数组里面的rgba颜色值</li>
<li>如果是Function函数值, 该函数返回一个rgba的数组值.</li>
</ul>
</li>
<li><p>getTargetColor(Function|Array, [0, 0, 0, 255]): 方法 — 检索位置颜色.</p>
<ul>
<li>同上</li>
</ul>
</li>
<li><p>getStrokeWidth(Function|Number, 1): 每个对象的笔画宽度，以像素为单位。</p>
<ul>
<li><p>如果提供了数字，则将其用作所有对象的笔划宽度.</p>
</li>
<li><p>如果提供了函数，则对每个对象调用该函数以检索其笔划宽度。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>2.GeoJsonLayer: GeoJson层接收GeoJson格式的数据，并将其呈现为交互式的多边形、线和点。</p>
<ul>
<li><p>怎么使用?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DeckGL, &#123;GeoJsonLayer&#125; <span class="keyword">from</span> <span class="string">'deck.gl'</span>;</span><br><span class="line"><span class="comment">// 用法和创建和之前的栗子差不多,只是渲染时的一些属性不同</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123;data, viewport&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;data, viewport&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Data format:</span></span><br><span class="line"><span class="comment">   * Valid GeoJSON object</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> layer = <span class="keyword">new</span> GeoJsonLayer(&#123;</span><br><span class="line">    id: <span class="string">'geojson-layer'</span>,</span><br><span class="line">    data,</span><br><span class="line">    pickable: <span class="literal">true</span>,</span><br><span class="line">    stroked: <span class="literal">false</span>,</span><br><span class="line">    filled: <span class="literal">true</span>,</span><br><span class="line">    extruded: <span class="literal">true</span>,</span><br><span class="line">    lineWidthScale: <span class="number">20</span>,</span><br><span class="line">    lineWidthMinPixels: <span class="number">2</span>,</span><br><span class="line">    getFillColor: [<span class="number">160</span>, <span class="number">160</span>, <span class="number">180</span>, <span class="number">200</span>],</span><br><span class="line">    getLineColor: <span class="function"><span class="params">d</span> =&gt;</span> colorToRGBArray(d.properties.color),</span><br><span class="line">    getRadius: <span class="number">100</span>,</span><br><span class="line">    getLineWidth: <span class="number">1</span>,</span><br><span class="line">    getElevation: <span class="number">30</span>,</span><br><span class="line">    onHover: <span class="function">(<span class="params">&#123;object, x, y&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> tooltip = object.properties.name || object.properties.station;</span><br><span class="line">      <span class="comment">/* Update tooltip</span></span><br><span class="line"><span class="comment">         http://deck.gl/#/documentation/developer-guide/adding-interactivity?section=example-display-a-tooltip-for-hovered-object</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">DeckGL</span> &#123;<span class="attr">...viewport</span>&#125; <span class="attr">layers</span>=<span class="string">&#123;[layer]&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染属性: 从所有基层属性继承而来的数据支柱被稍微灵活地解释了一下，以适应纯粹的GeoJson“有效负载”。</p>
<ol>
<li>filled(Boolean, true): 是否绘制填充多边形(实体填充)。注意，对于每个多边形，只有外部多边形和任何孔之间的区域将被填充。这个道具只有在多边形没有被挤压的情况下才有效。</li>
<li>stroked(Boolean, false): 是否绘制多边形的轮廓(固体填充)。注意，对于复杂的多边形，将绘制外部多边形以及任何孔的轮廓。</li>
<li>extruded(Boolean, false): 如果设置为true，沿z轴挤压多边形和多多边形特征。绘制的特征的高度是通过getElevation访问器获得的。</li>
<li>wireframe(boolean, false): 是否生成六边形的线框。轮廓将有“水平”线关闭的顶部和底部多边形和垂直线(“支柱”)的每个顶点的多边形.<ul>
<li>只有当extruded设置为true是才有效</li>
</ul>
</li>
<li>lineWidthScale(Boolean, 1): 行宽乘法器，用于乘到所有行，包括LineString和MultiLineString特性，如果描边属性为真，还包括多边形和多多边形特性的轮廓。</li>
<li>lineWidthMinPixels(Number, 0): 最小行宽，以像素为单位。</li>
<li>lineWidthMaxPixels(Number, Number.MAX_SAFE_INTEGER): 最大行宽, 像素为单位</li>
<li>lineJointRounded(Boolean, false): 两条geo线连接重叠部分的样式.</li>
<li>lineMiterLimit(Number, 4): 一个l连接点的最大宽度与行宽度之比。只有当linejointround为假时才有效.</li>
<li>elevationScale(Number, 1): 海拔乘数。最终高程按海拔比例尺* getElevation(d)计算。elevationScale是一个处理的属性，可以在不更新数据的情况下缩放所有多边形的高程。</li>
<li>pointRadiusScale(Numbel, 1): 所有点的全局半径乘法器。</li>
</ol>
</li>
<li><p>数据访问器</p>
<ol>
<li>getLineColor(Function|Array, [0, 0,0,255]): 根据GeoJson特性的类型，行字符串的rgba颜色和/或多边形的轮廓。格式为r, g, b， [a]。每个组件都在0-255范围内。</li>
<li>gitFillColor(Function|Array, [0,0,0,255]): GeoJson的多边形和点特征的纯色。格式为r, g, b， [a]。每个组件都在0-255范围内。</li>
<li>getRadius(Function|Number): 点的半径和多点特征，以米为单位。</li>
<li>getLineWidth(Function|Number): 根据GeoJson特性的类型，行字符串的宽度和/或多边形的轮廓。单位是米。</li>
<li>getElevation(Function|Number): 多边形特征的高程(挤压时为真)。</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>HexagonLayer</p>
<ul>
<li><p>六边形层根据点数组呈现一个六边形热图。它取六边形仓的半径，投影到六边形仓中。六边形的颜色和高度由它包含的点的数量来决定。</p>
</li>
<li><p>怎么使用?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DeckGL, &#123;HexagonLayer&#125; <span class="keyword">from</span> <span class="string">'deck.gl'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123;data, viewport&#125;</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Data format:</span></span><br><span class="line"><span class="comment">   * [</span></span><br><span class="line"><span class="comment">   *   &#123;COORDINATES: [-122.42177834, 37.78346622]&#125;,</span></span><br><span class="line"><span class="comment">   *   ...</span></span><br><span class="line"><span class="comment">   * ]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> layer = <span class="keyword">new</span> HexagonLayer(&#123;</span><br><span class="line">    id: <span class="string">'hexagon-layer'</span>,</span><br><span class="line">    data,</span><br><span class="line">    pickable: <span class="literal">true</span>,</span><br><span class="line">    extruded: <span class="literal">true</span>,</span><br><span class="line">    radius: <span class="number">200</span>,</span><br><span class="line">    elevationScale: <span class="number">4</span>,</span><br><span class="line">    getPosition: <span class="function"><span class="params">d</span> =&gt;</span> d.COORDINATES,</span><br><span class="line">    onHover: <span class="function">(<span class="params">&#123;object, x, y&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> tooltip = <span class="string">`<span class="subst">$&#123;object.centroid.join(<span class="string">', '</span>)&#125;</span>\nCount: <span class="subst">$&#123;object.points.length&#125;</span>`</span>;</span><br><span class="line">      <span class="comment">/* Update tooltip</span></span><br><span class="line"><span class="comment">         http://deck.gl/#/documentation/developer-guide/adding-interactivity?section=example-display-a-tooltip-for-hovered-object</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">DeckGL</span> &#123;<span class="attr">...viewport</span>&#125; <span class="attr">layers</span>=<span class="string">&#123;[layer]&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染属性</p>
<ol>
<li>radius(Number, 1000): 六角形料斗半径(米)。六边形是尖顶的(而不是平顶的)。</li>
<li>hexagonAggregator(Function, d3-hexbin): 六边形聚合器是将数据聚合到六边形容器中的函数。六边形聚合器将层的道具和当前视图作为参数。输出应该是{六边形:[]，六边形顶点:[]}。六边形是{centroid: []， points:[]}的数组，其中centroid是六边形的中心，points是六边形包含的点的数组。六边形顶点(可选)是定义基本六边形几何形状的点数组.</li>
<li>colorRange(Array): 颜色值数组,用来创建六边形因密度不同而形成的颜色区分;</li>
<li>coverage(Number): 六角半径乘法器，夹在0 - 1之间。六边形的最终半径是用覆盖率*半径来计算的。注意:覆盖率不影响点的绑定方式。容器的半径仅由半径属性决定。</li>
<li>elevationDomain(Array, [0, Max(count)]):  高程刻度输入域。高程比例尺是一种线性比例尺，它将计数的数量映射到高程。默认情况下，它被设置为在每个六边形的点计数的0到最大值之间。当您希望使用相同的高程比例呈现不同的数据输入以进行比较时，此属性非常方便。</li>
<li>elevationRange(Array, [0, 1000]): 高程刻度输出范围</li>
<li>elevationScale(Number, 1): 六角海拔乘数。实际高程按elevationScale* getElevation(d)计算。elevationScale是一个方便的属性，可以在不更新数据的情况下缩放所有六边形.</li>
<li>extruded(Boolean, false): 是否启用单元格提升。单元格高程按每个单元格中的点数计算。如果设置为false，则所有单元格都是扁平的。</li>
<li>upperPercentile(Number, 100):  过滤箱和重新计算颜色的上位百分比。颜色值大于上百分位的六边形将被隐藏(控制数据量密度的值,值越大,密度要更大才能更好的区分)</li>
<li>lowerPercentile(Number, 0): 过滤箱和重新计算颜色的较低百分位。颜色值小于最小百分位数的六边形将被隐藏。(密度控制阀, 越低,密度越低的颜色有区分)</li>
<li>elevationUpperPercentile(Number, 100): 过滤箱和重新计算海拔高度的海拔上百分位。高程值大于上百分位的六边形将被隐藏</li>
<li>elevationLowerPercentile(Number, 0): 过滤箱和重新计算海拔高度由海拔低百分位。标高小于标高的六边形将被隐藏。</li>
<li>lightSettings(Object): 这个对象包含挤压多边形的灯光设置。请注意，这个道具可能会在deck.gl的未来版本中更改.</li>
</ol>
</li>
<li><p>数据访问器</p>
<ol>
<li><p>getPosition(Function): 方法来检索每个点的位置。</p>
</li>
<li><p>getColorValue(Function): getColorValue是获取bin color所基于的值的访问器函数。它将每个bin中的点数组作为参数，返回一个数字。例如，可以通过每个点的特定属性的avg/mean/max，将getColorValue传递给颜色容器。默认情况下，getColorValue返回点数组的长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHexagonLayer</span> </span>&#123;</span><br><span class="line">   getColorValue (points) &#123;</span><br><span class="line">       <span class="keyword">return</span> points.length;</span><br><span class="line">   &#125;</span><br><span class="line">           </span><br><span class="line">   renderLayers() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> HexagonLayer(&#123;</span><br><span class="line">       id: <span class="string">'hexagon-layer'</span>,</span><br><span class="line">       getColorValue: <span class="keyword">this</span>.getColorValue <span class="comment">// instead of getColorValue: (points) =&gt; &#123; return points.length; &#125;</span></span><br><span class="line">       data,</span><br><span class="line">       radius: <span class="number">500</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getElevationValue(Function): 类似于getColorValue, getElevationValue是获取bin elevation所基于的值的访问器函数。它将每个bin中的点数组作为参数，返回一个数字。默认情况下，getElevationValue返回点数组的长度</p>
</li>
<li><p>onSetColorDomain(Function): 计算bin颜色域时将调用此回调。</p>
</li>
<li><p>onSetElevationDomain(Function): 当bin海拔域计算完成时，将调用此回调。</p>
</li>
</ol>
</li>
</ul>
<p>注: 还有其他layer层的类,可以去官网上阅读,其实每个层的类的用法都一样,只是,每个层有其不一样的属性,结合不一样的属性创建不一样的动画,或者物体.</p>
</li>
</ol>
</li>
<li><p>shader modules — 着色器模块 —请自行查询官网</p>
</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="//likamoer.me/2019/08/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="likamoer">
      <meta itemprop="description" content="爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小新没蜡笔的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/20/hello-world/" class="post-title-link" itemprop="url">开始我的博客之旅</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-20 10:21:49 / 修改时间：11:59:58" itemprop="dateCreated datePublished" datetime="2019-08-20T10:21:49+08:00">2019-08-20</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://likamoer.github.io/" target="_blank" rel="noopener">my blog</a>! </p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </section>

  


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="likamoer">
  <p class="site-author-name" itemprop="name">likamoer</p>
  <div class="site-description motion-element" itemprop="description">爱折腾的前端码农一枚, 爱好广泛, 不喜欢敲代码, 纯属为了生活,在前端可视化方面有一定的研究,追随前端技术,将前端折腾到底!!!</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://juejin.im/user/5a3bb0c0f265da43085e33b1" title="Juejin &rarr; https://juejin.im/user/5a3bb0c0f265da43085e33b1" rel="noopener" target="_blank"><i class="fa fa-fw fa-legal"></i>Juejin</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/likamoer" title="GitHub &rarr; https://github.com/likamoer" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:li_hx214@163.com" title="E-Mail &rarr; mailto:li_hx214@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>




        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">likamoer</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>-->

        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        <span>0%</span>
      </div>

    

  </div>

  
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  


























  

  

  


  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
